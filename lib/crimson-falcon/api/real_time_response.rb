=begin
Crimson Falcon - Ruby Client SDK

Code auto-generated by OpenAPI Generator; DO NOT EDIT.

MIT License

Copyright (c) 2023 Crowdstrike

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

=end

require 'cgi'

module Falcon
  class RealTimeResponse
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Batch executes a RTR active-responder command across the hosts mapped to the given batch ID.
    # @param body [DomainBatchExecuteCommandRequest] Use this endpoint to run these [real time response commands](https://falcon.crowdstrike.com/documentation/page/b8c1738c/real-time-response-and-network-containment#k893b7c0): - &#x60;cat&#x60; - &#x60;cd&#x60; - &#x60;clear&#x60; - &#x60;cp&#x60; - &#x60;encrypt&#x60; - &#x60;env&#x60; - &#x60;eventlog&#x60; - &#x60;filehash&#x60; - &#x60;get&#x60; - &#x60;getsid&#x60; - &#x60;help&#x60; - &#x60;history&#x60; - &#x60;ipconfig&#x60; - &#x60;kill&#x60; - &#x60;ls&#x60; - &#x60;map&#x60; - &#x60;memdump&#x60; - &#x60;mkdir&#x60; - &#x60;mount&#x60; - &#x60;mv&#x60; - &#x60;netstat&#x60; - &#x60;ps&#x60; - &#x60;reg query&#x60; - &#x60;reg set&#x60; - &#x60;reg delete&#x60; - &#x60;reg load&#x60; - &#x60;reg unload&#x60; - &#x60;restart&#x60; - &#x60;rm&#x60; - &#x60;runscript&#x60; - &#x60;shutdown&#x60; - &#x60;unmap&#x60; - &#x60;update history&#x60; - &#x60;update install&#x60; - &#x60;update list&#x60; - &#x60;update query&#x60; - &#x60;xmemdump&#x60; - &#x60;zip&#x60;  **&#x60;base_command&#x60;** Active-Responder command type we are going to execute, for example: &#x60;get&#x60; or &#x60;cp&#x60;.  Refer to the RTR documentation for the full list of commands. **&#x60;batch_id&#x60;** Batch ID to execute the command on.  Received from &#x60;/real-time-response/combined/batch-init-session/v1&#x60;. **&#x60;command_string&#x60;** Full command string for the command. For example  &#x60;get some_file.txt&#x60; **&#x60;optional_hosts&#x60;** List of a subset of hosts we want to run the command on.  If this list is supplied, only these hosts will receive the command.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @option opts [String] :host_timeout_duration Timeout duration for how long a host has time to complete processing. Default value is a bit less than the overall timeout value. It cannot be greater than the overall request timeout. Maximum is &lt; 5 minutes. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;.  (default to 'tiny bit less than overall request timeout')
    # @return [DomainMultiCommandExecuteResponseWrapper]
    def batch_active_responder_cmd(body, opts = {})
      data, _status_code, _headers = batch_active_responder_cmd_with_http_info(body, opts)
      data
    end

    # Batch executes a RTR active-responder command across the hosts mapped to the given batch ID.
    # @param body [DomainBatchExecuteCommandRequest] Use this endpoint to run these [real time response commands](https://falcon.crowdstrike.com/documentation/page/b8c1738c/real-time-response-and-network-containment#k893b7c0): - &#x60;cat&#x60; - &#x60;cd&#x60; - &#x60;clear&#x60; - &#x60;cp&#x60; - &#x60;encrypt&#x60; - &#x60;env&#x60; - &#x60;eventlog&#x60; - &#x60;filehash&#x60; - &#x60;get&#x60; - &#x60;getsid&#x60; - &#x60;help&#x60; - &#x60;history&#x60; - &#x60;ipconfig&#x60; - &#x60;kill&#x60; - &#x60;ls&#x60; - &#x60;map&#x60; - &#x60;memdump&#x60; - &#x60;mkdir&#x60; - &#x60;mount&#x60; - &#x60;mv&#x60; - &#x60;netstat&#x60; - &#x60;ps&#x60; - &#x60;reg query&#x60; - &#x60;reg set&#x60; - &#x60;reg delete&#x60; - &#x60;reg load&#x60; - &#x60;reg unload&#x60; - &#x60;restart&#x60; - &#x60;rm&#x60; - &#x60;runscript&#x60; - &#x60;shutdown&#x60; - &#x60;unmap&#x60; - &#x60;update history&#x60; - &#x60;update install&#x60; - &#x60;update list&#x60; - &#x60;update query&#x60; - &#x60;xmemdump&#x60; - &#x60;zip&#x60;  **&#x60;base_command&#x60;** Active-Responder command type we are going to execute, for example: &#x60;get&#x60; or &#x60;cp&#x60;.  Refer to the RTR documentation for the full list of commands. **&#x60;batch_id&#x60;** Batch ID to execute the command on.  Received from &#x60;/real-time-response/combined/batch-init-session/v1&#x60;. **&#x60;command_string&#x60;** Full command string for the command. For example  &#x60;get some_file.txt&#x60; **&#x60;optional_hosts&#x60;** List of a subset of hosts we want to run the command on.  If this list is supplied, only these hosts will receive the command.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @option opts [String] :host_timeout_duration Timeout duration for how long a host has time to complete processing. Default value is a bit less than the overall timeout value. It cannot be greater than the overall request timeout. Maximum is &lt; 5 minutes. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;.  (default to 'tiny bit less than overall request timeout')
    # @return [Array<(DomainMultiCommandExecuteResponseWrapper, Integer, Hash)>] DomainMultiCommandExecuteResponseWrapper data, response status code and response headers
    def batch_active_responder_cmd_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.batch_active_responder_cmd ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling RealTimeResponse.batch_active_responder_cmd"
      end
      # resource path
      local_var_path = '/real-time-response/combined/batch-active-responder-command/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'timeout'] = opts[:'timeout'] if !opts[:'timeout'].nil?
      query_params[:'timeout_duration'] = opts[:'timeout_duration'] if !opts[:'timeout_duration'].nil?
      query_params[:'host_timeout_duration'] = opts[:'host_timeout_duration'] if !opts[:'host_timeout_duration'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'DomainMultiCommandExecuteResponseWrapper'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.batch_active_responder_cmd",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#batch_active_responder_cmd\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Batch executes a RTR read-only command across the hosts mapped to the given batch ID.
    # @param body [DomainBatchExecuteCommandRequest] Use this endpoint to run these [real time response commands](https://falcon.crowdstrike.com/documentation/page/b8c1738c/real-time-response-and-network-containment#k893b7c0): - &#x60;cat&#x60; - &#x60;cd&#x60; - &#x60;clear&#x60; - &#x60;env&#x60; - &#x60;eventlog&#x60; - &#x60;filehash&#x60; - &#x60;getsid&#x60; - &#x60;help&#x60; - &#x60;history&#x60; - &#x60;ipconfig&#x60; - &#x60;ls&#x60; - &#x60;mount&#x60; - &#x60;netstat&#x60; - &#x60;ps&#x60; - &#x60;reg query&#x60;  **&#x60;base_command&#x60;** read-only command type we are going to execute, for example: &#x60;ls&#x60; or &#x60;cd&#x60;.  Refer to the RTR documentation for the full list of commands. **&#x60;batch_id&#x60;** Batch ID to execute the command on.  Received from &#x60;/real-time-response/combined/batch-init-session/v1&#x60;. **&#x60;command_string&#x60;** Full command string for the command. For example  &#x60;cd C:\\some_directory&#x60; **&#x60;optional_hosts&#x60;** List of a subset of hosts we want to run the command on.  If this list is supplied, only these hosts will receive the command.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @option opts [String] :host_timeout_duration Timeout duration for how long a host has time to complete processing. Default value is a bit less than the overall timeout value. It cannot be greater than the overall request timeout. Maximum is &lt; 5 minutes. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;.  (default to 'tiny bit less than overall request timeout')
    # @return [DomainMultiCommandExecuteResponseWrapper]
    def batch_cmd(body, opts = {})
      data, _status_code, _headers = batch_cmd_with_http_info(body, opts)
      data
    end

    # Batch executes a RTR read-only command across the hosts mapped to the given batch ID.
    # @param body [DomainBatchExecuteCommandRequest] Use this endpoint to run these [real time response commands](https://falcon.crowdstrike.com/documentation/page/b8c1738c/real-time-response-and-network-containment#k893b7c0): - &#x60;cat&#x60; - &#x60;cd&#x60; - &#x60;clear&#x60; - &#x60;env&#x60; - &#x60;eventlog&#x60; - &#x60;filehash&#x60; - &#x60;getsid&#x60; - &#x60;help&#x60; - &#x60;history&#x60; - &#x60;ipconfig&#x60; - &#x60;ls&#x60; - &#x60;mount&#x60; - &#x60;netstat&#x60; - &#x60;ps&#x60; - &#x60;reg query&#x60;  **&#x60;base_command&#x60;** read-only command type we are going to execute, for example: &#x60;ls&#x60; or &#x60;cd&#x60;.  Refer to the RTR documentation for the full list of commands. **&#x60;batch_id&#x60;** Batch ID to execute the command on.  Received from &#x60;/real-time-response/combined/batch-init-session/v1&#x60;. **&#x60;command_string&#x60;** Full command string for the command. For example  &#x60;cd C:\\some_directory&#x60; **&#x60;optional_hosts&#x60;** List of a subset of hosts we want to run the command on.  If this list is supplied, only these hosts will receive the command.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @option opts [String] :host_timeout_duration Timeout duration for how long a host has time to complete processing. Default value is a bit less than the overall timeout value. It cannot be greater than the overall request timeout. Maximum is &lt; 5 minutes. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;.  (default to 'tiny bit less than overall request timeout')
    # @return [Array<(DomainMultiCommandExecuteResponseWrapper, Integer, Hash)>] DomainMultiCommandExecuteResponseWrapper data, response status code and response headers
    def batch_cmd_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.batch_cmd ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling RealTimeResponse.batch_cmd"
      end
      # resource path
      local_var_path = '/real-time-response/combined/batch-command/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'timeout'] = opts[:'timeout'] if !opts[:'timeout'].nil?
      query_params[:'timeout_duration'] = opts[:'timeout_duration'] if !opts[:'timeout_duration'].nil?
      query_params[:'host_timeout_duration'] = opts[:'host_timeout_duration'] if !opts[:'host_timeout_duration'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'DomainMultiCommandExecuteResponseWrapper'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.batch_cmd",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#batch_cmd\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Batch executes `get` command across hosts to retrieve files. After this call is made `GET /real-time-response/combined/batch-get-command/v1` is used to query for the results.
    # @param body [DomainBatchGetCommandRequest] **&#x60;batch_id&#x60;** Batch ID to execute the command on.  Received from &#x60;/real-time-response/combined/batch-init-session/v1&#x60;. **&#x60;file_path&#x60;** Full path to the file that is to be retrieved from each host in the batch. **&#x60;optional_hosts&#x60;** List of a subset of hosts we want to run the command on.  If this list is supplied, only these hosts will receive the command.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @option opts [String] :host_timeout_duration Timeout duration for how long a host has time to complete processing. Default value is a bit less than the overall timeout value. It cannot be greater than the overall request timeout. Maximum is &lt; 5 minutes. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;.  (default to 'tiny bit less than overall request timeout')
    # @return [DomainBatchGetCommandResponse]
    def batch_get_cmd(body, opts = {})
      data, _status_code, _headers = batch_get_cmd_with_http_info(body, opts)
      data
    end

    # Batch executes &#x60;get&#x60; command across hosts to retrieve files. After this call is made &#x60;GET /real-time-response/combined/batch-get-command/v1&#x60; is used to query for the results.
    # @param body [DomainBatchGetCommandRequest] **&#x60;batch_id&#x60;** Batch ID to execute the command on.  Received from &#x60;/real-time-response/combined/batch-init-session/v1&#x60;. **&#x60;file_path&#x60;** Full path to the file that is to be retrieved from each host in the batch. **&#x60;optional_hosts&#x60;** List of a subset of hosts we want to run the command on.  If this list is supplied, only these hosts will receive the command.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @option opts [String] :host_timeout_duration Timeout duration for how long a host has time to complete processing. Default value is a bit less than the overall timeout value. It cannot be greater than the overall request timeout. Maximum is &lt; 5 minutes. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;.  (default to 'tiny bit less than overall request timeout')
    # @return [Array<(DomainBatchGetCommandResponse, Integer, Hash)>] DomainBatchGetCommandResponse data, response status code and response headers
    def batch_get_cmd_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.batch_get_cmd ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling RealTimeResponse.batch_get_cmd"
      end
      # resource path
      local_var_path = '/real-time-response/combined/batch-get-command/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'timeout'] = opts[:'timeout'] if !opts[:'timeout'].nil?
      query_params[:'timeout_duration'] = opts[:'timeout_duration'] if !opts[:'timeout_duration'].nil?
      query_params[:'host_timeout_duration'] = opts[:'host_timeout_duration'] if !opts[:'host_timeout_duration'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'DomainBatchGetCommandResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.batch_get_cmd",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#batch_get_cmd\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieves the status of the specified batch get command.  Will return successful files when they are finished processing.
    # @param batch_get_cmd_req_id [String] Batch Get Command Request ID received from &#x60;/real-time-response/combined/get-command/v1&#x60;
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @return [DomainBatchGetCmdStatusResponse]
    def batch_get_cmd_status(batch_get_cmd_req_id, opts = {})
      data, _status_code, _headers = batch_get_cmd_status_with_http_info(batch_get_cmd_req_id, opts)
      data
    end

    # Retrieves the status of the specified batch get command.  Will return successful files when they are finished processing.
    # @param batch_get_cmd_req_id [String] Batch Get Command Request ID received from &#x60;/real-time-response/combined/get-command/v1&#x60;
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @return [Array<(DomainBatchGetCmdStatusResponse, Integer, Hash)>] DomainBatchGetCmdStatusResponse data, response status code and response headers
    def batch_get_cmd_status_with_http_info(batch_get_cmd_req_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.batch_get_cmd_status ...'
      end
      # verify the required parameter 'batch_get_cmd_req_id' is set
      if @api_client.config.client_side_validation && batch_get_cmd_req_id.nil?
        fail ArgumentError, "Missing the required parameter 'batch_get_cmd_req_id' when calling RealTimeResponse.batch_get_cmd_status"
      end
      # resource path
      local_var_path = '/real-time-response/combined/batch-get-command/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'batch_get_cmd_req_id'] = batch_get_cmd_req_id
      query_params[:'timeout'] = opts[:'timeout'] if !opts[:'timeout'].nil?
      query_params[:'timeout_duration'] = opts[:'timeout_duration'] if !opts[:'timeout_duration'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DomainBatchGetCmdStatusResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.batch_get_cmd_status",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#batch_get_cmd_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Batch initialize a RTR session on multiple hosts.  Before any RTR commands can be used, an active session is needed on the host.
    # @param body [DomainBatchInitSessionRequest] **&#x60;host_ids&#x60;** List of host agent ID&#39;s to initialize a RTR session on. A maximum of 10000 hosts can be in a single batch session. **&#x60;existing_batch_id&#x60;** Optional batch ID. Use an existing batch ID if you want to initialize new hosts and add them to the existing batch **&#x60;queue_offline&#x60;** If we should queue this session if the host is offline.  Any commands run against an offline-queued session will be queued up and executed when the host comes online.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @option opts [String] :host_timeout_duration Timeout duration for how long a host has time to complete processing. Default value is a bit less than the overall timeout value. It cannot be greater than the overall request timeout. Maximum is &lt; 5 minutes. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;.  (default to 'tiny bit less than overall request timeout')
    # @return [DomainBatchInitSessionResponse]
    def batch_init_sessions(body, opts = {})
      data, _status_code, _headers = batch_init_sessions_with_http_info(body, opts)
      data
    end

    # Batch initialize a RTR session on multiple hosts.  Before any RTR commands can be used, an active session is needed on the host.
    # @param body [DomainBatchInitSessionRequest] **&#x60;host_ids&#x60;** List of host agent ID&#39;s to initialize a RTR session on. A maximum of 10000 hosts can be in a single batch session. **&#x60;existing_batch_id&#x60;** Optional batch ID. Use an existing batch ID if you want to initialize new hosts and add them to the existing batch **&#x60;queue_offline&#x60;** If we should queue this session if the host is offline.  Any commands run against an offline-queued session will be queued up and executed when the host comes online.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @option opts [String] :host_timeout_duration Timeout duration for how long a host has time to complete processing. Default value is a bit less than the overall timeout value. It cannot be greater than the overall request timeout. Maximum is &lt; 5 minutes. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;.  (default to 'tiny bit less than overall request timeout')
    # @return [Array<(DomainBatchInitSessionResponse, Integer, Hash)>] DomainBatchInitSessionResponse data, response status code and response headers
    def batch_init_sessions_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.batch_init_sessions ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling RealTimeResponse.batch_init_sessions"
      end
      # resource path
      local_var_path = '/real-time-response/combined/batch-init-session/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'timeout'] = opts[:'timeout'] if !opts[:'timeout'].nil?
      query_params[:'timeout_duration'] = opts[:'timeout_duration'] if !opts[:'timeout_duration'].nil?
      query_params[:'host_timeout_duration'] = opts[:'host_timeout_duration'] if !opts[:'host_timeout_duration'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'DomainBatchInitSessionResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.batch_init_sessions",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#batch_init_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Batch refresh a RTR session on multiple hosts. RTR sessions will expire after 10 minutes unless refreshed.
    # @param body [DomainBatchRefreshSessionRequest] **&#x60;batch_id&#x60;** Batch ID to execute the command on.  Received from &#x60;/real-time-response/combined/batch-init-session/v1&#x60;. **&#x60;hosts_to_remove&#x60;** Hosts to remove from the batch session.  Heartbeats will no longer happen on these hosts and the sessions will expire.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @return [DomainBatchRefreshSessionResponse]
    def batch_refresh_sessions(body, opts = {})
      data, _status_code, _headers = batch_refresh_sessions_with_http_info(body, opts)
      data
    end

    # Batch refresh a RTR session on multiple hosts. RTR sessions will expire after 10 minutes unless refreshed.
    # @param body [DomainBatchRefreshSessionRequest] **&#x60;batch_id&#x60;** Batch ID to execute the command on.  Received from &#x60;/real-time-response/combined/batch-init-session/v1&#x60;. **&#x60;hosts_to_remove&#x60;** Hosts to remove from the batch session.  Heartbeats will no longer happen on these hosts and the sessions will expire.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @return [Array<(DomainBatchRefreshSessionResponse, Integer, Hash)>] DomainBatchRefreshSessionResponse data, response status code and response headers
    def batch_refresh_sessions_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.batch_refresh_sessions ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling RealTimeResponse.batch_refresh_sessions"
      end
      # resource path
      local_var_path = '/real-time-response/combined/batch-refresh-session/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'timeout'] = opts[:'timeout'] if !opts[:'timeout'].nil?
      query_params[:'timeout_duration'] = opts[:'timeout_duration'] if !opts[:'timeout_duration'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'DomainBatchRefreshSessionResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.batch_refresh_sessions",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#batch_refresh_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get aggregates on session data.
    # @param body [Array<MsaAggregateQueryRequest>] Supported aggregations:  - &#x60;term&#x60; - &#x60;date_range&#x60;  Supported aggregation members:  **&#x60;date_ranges&#x60;** If peforming a date range query specify the **&#x60;from&#x60;** and **&#x60;to&#x60;** date ranges.  These can be in common date formats like &#x60;2019-07-18&#x60; or &#x60;now&#x60; **&#x60;field&#x60;** Term you want to aggregate on.  If doing a &#x60;date_range&#x60; query, this is the date field you want to apply the date ranges to **&#x60;filter&#x60;** Optional filter criteria in the form of an FQL query. For more information about FQL queries, see our [FQL documentation in Falcon](https://falcon.crowdstrike.com/support/documentation/45/falcon-query-language-feature-guide). **&#x60;name&#x60;** Name of the aggregation **&#x60;size&#x60;** Size limit to apply to the queries.
    # @param [Hash] opts the optional parameters
    # @return [MsaAggregatesResponse]
    def r_tr_aggregate_sessions(body, opts = {})
      data, _status_code, _headers = r_tr_aggregate_sessions_with_http_info(body, opts)
      data
    end

    # Get aggregates on session data.
    # @param body [Array<MsaAggregateQueryRequest>] Supported aggregations:  - &#x60;term&#x60; - &#x60;date_range&#x60;  Supported aggregation members:  **&#x60;date_ranges&#x60;** If peforming a date range query specify the **&#x60;from&#x60;** and **&#x60;to&#x60;** date ranges.  These can be in common date formats like &#x60;2019-07-18&#x60; or &#x60;now&#x60; **&#x60;field&#x60;** Term you want to aggregate on.  If doing a &#x60;date_range&#x60; query, this is the date field you want to apply the date ranges to **&#x60;filter&#x60;** Optional filter criteria in the form of an FQL query. For more information about FQL queries, see our [FQL documentation in Falcon](https://falcon.crowdstrike.com/support/documentation/45/falcon-query-language-feature-guide). **&#x60;name&#x60;** Name of the aggregation **&#x60;size&#x60;** Size limit to apply to the queries.
    # @param [Hash] opts the optional parameters
    # @return [Array<(MsaAggregatesResponse, Integer, Hash)>] MsaAggregatesResponse data, response status code and response headers
    def r_tr_aggregate_sessions_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_aggregate_sessions ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling RealTimeResponse.r_tr_aggregate_sessions"
      end
      # resource path
      local_var_path = '/real-time-response/aggregates/sessions/GET/v1'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'MsaAggregatesResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_aggregate_sessions",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_aggregate_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get status of an executed active-responder command on a single host.
    # @param cloud_request_id [String] Cloud Request ID of the executed command to query
    # @param sequence_id [Integer] Sequence ID that we want to retrieve. Command responses are chunked across sequences
    # @param [Hash] opts the optional parameters
    # @return [DomainStatusResponseWrapper]
    def r_tr_check_active_responder_command_status(cloud_request_id, sequence_id, opts = {})
      data, _status_code, _headers = r_tr_check_active_responder_command_status_with_http_info(cloud_request_id, sequence_id, opts)
      data
    end

    # Get status of an executed active-responder command on a single host.
    # @param cloud_request_id [String] Cloud Request ID of the executed command to query
    # @param sequence_id [Integer] Sequence ID that we want to retrieve. Command responses are chunked across sequences
    # @param [Hash] opts the optional parameters
    # @return [Array<(DomainStatusResponseWrapper, Integer, Hash)>] DomainStatusResponseWrapper data, response status code and response headers
    def r_tr_check_active_responder_command_status_with_http_info(cloud_request_id, sequence_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_check_active_responder_command_status ...'
      end
      # verify the required parameter 'cloud_request_id' is set
      if @api_client.config.client_side_validation && cloud_request_id.nil?
        fail ArgumentError, "Missing the required parameter 'cloud_request_id' when calling RealTimeResponse.r_tr_check_active_responder_command_status"
      end
      # verify the required parameter 'sequence_id' is set
      if @api_client.config.client_side_validation && sequence_id.nil?
        fail ArgumentError, "Missing the required parameter 'sequence_id' when calling RealTimeResponse.r_tr_check_active_responder_command_status"
      end
      # resource path
      local_var_path = '/real-time-response/entities/active-responder-command/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cloud_request_id'] = cloud_request_id
      query_params[:'sequence_id'] = sequence_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DomainStatusResponseWrapper'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_check_active_responder_command_status",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_check_active_responder_command_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get status of an executed command on a single host.
    # @param cloud_request_id [String] Cloud Request ID of the executed command to query
    # @param sequence_id [Integer] Sequence ID that we want to retrieve. Command responses are chunked across sequences
    # @param [Hash] opts the optional parameters
    # @return [DomainStatusResponseWrapper]
    def r_tr_check_command_status(cloud_request_id, sequence_id, opts = {})
      data, _status_code, _headers = r_tr_check_command_status_with_http_info(cloud_request_id, sequence_id, opts)
      data
    end

    # Get status of an executed command on a single host.
    # @param cloud_request_id [String] Cloud Request ID of the executed command to query
    # @param sequence_id [Integer] Sequence ID that we want to retrieve. Command responses are chunked across sequences
    # @param [Hash] opts the optional parameters
    # @return [Array<(DomainStatusResponseWrapper, Integer, Hash)>] DomainStatusResponseWrapper data, response status code and response headers
    def r_tr_check_command_status_with_http_info(cloud_request_id, sequence_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_check_command_status ...'
      end
      # verify the required parameter 'cloud_request_id' is set
      if @api_client.config.client_side_validation && cloud_request_id.nil?
        fail ArgumentError, "Missing the required parameter 'cloud_request_id' when calling RealTimeResponse.r_tr_check_command_status"
      end
      # verify the required parameter 'sequence_id' is set
      if @api_client.config.client_side_validation && sequence_id.nil?
        fail ArgumentError, "Missing the required parameter 'sequence_id' when calling RealTimeResponse.r_tr_check_command_status"
      end
      # resource path
      local_var_path = '/real-time-response/entities/command/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cloud_request_id'] = cloud_request_id
      query_params[:'sequence_id'] = sequence_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DomainStatusResponseWrapper'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_check_command_status",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_check_command_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a RTR session file.
    # @param ids [String] RTR Session file id
    # @param session_id [String] RTR Session id
    # @param [Hash] opts the optional parameters
    # @return [MsaReplyMetaOnly]
    def r_tr_delete_file(ids, session_id, opts = {})
      data, _status_code, _headers = r_tr_delete_file_with_http_info(ids, session_id, opts)
      data
    end

    # Delete a RTR session file.
    # @param ids [String] RTR Session file id
    # @param session_id [String] RTR Session id
    # @param [Hash] opts the optional parameters
    # @return [Array<(MsaReplyMetaOnly, Integer, Hash)>] MsaReplyMetaOnly data, response status code and response headers
    def r_tr_delete_file_with_http_info(ids, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_delete_file ...'
      end
      # verify the required parameter 'ids' is set
      if @api_client.config.client_side_validation && ids.nil?
        fail ArgumentError, "Missing the required parameter 'ids' when calling RealTimeResponse.r_tr_delete_file"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling RealTimeResponse.r_tr_delete_file"
      end
      # resource path
      local_var_path = '/real-time-response/entities/file/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'ids'] = ids
      query_params[:'session_id'] = session_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MsaReplyMetaOnly'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_delete_file",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_delete_file\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a RTR session file.
    # @param ids [String] RTR Session file id
    # @param session_id [String] RTR Session id
    # @param [Hash] opts the optional parameters
    # @return [MsaReplyMetaOnly]
    def r_tr_delete_file_v2(ids, session_id, opts = {})
      data, _status_code, _headers = r_tr_delete_file_v2_with_http_info(ids, session_id, opts)
      data
    end

    # Delete a RTR session file.
    # @param ids [String] RTR Session file id
    # @param session_id [String] RTR Session id
    # @param [Hash] opts the optional parameters
    # @return [Array<(MsaReplyMetaOnly, Integer, Hash)>] MsaReplyMetaOnly data, response status code and response headers
    def r_tr_delete_file_v2_with_http_info(ids, session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_delete_file_v2 ...'
      end
      # verify the required parameter 'ids' is set
      if @api_client.config.client_side_validation && ids.nil?
        fail ArgumentError, "Missing the required parameter 'ids' when calling RealTimeResponse.r_tr_delete_file_v2"
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling RealTimeResponse.r_tr_delete_file_v2"
      end
      # resource path
      local_var_path = '/real-time-response/entities/file/v2'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'ids'] = ids
      query_params[:'session_id'] = session_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MsaReplyMetaOnly'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_delete_file_v2",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_delete_file_v2\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a queued session command
    # @param session_id [String] RTR Session id
    # @param cloud_request_id [String] Cloud Request ID of the executed command to query
    # @param [Hash] opts the optional parameters
    # @return [MsaReplyMetaOnly]
    def r_tr_delete_queued_session(session_id, cloud_request_id, opts = {})
      data, _status_code, _headers = r_tr_delete_queued_session_with_http_info(session_id, cloud_request_id, opts)
      data
    end

    # Delete a queued session command
    # @param session_id [String] RTR Session id
    # @param cloud_request_id [String] Cloud Request ID of the executed command to query
    # @param [Hash] opts the optional parameters
    # @return [Array<(MsaReplyMetaOnly, Integer, Hash)>] MsaReplyMetaOnly data, response status code and response headers
    def r_tr_delete_queued_session_with_http_info(session_id, cloud_request_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_delete_queued_session ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling RealTimeResponse.r_tr_delete_queued_session"
      end
      # verify the required parameter 'cloud_request_id' is set
      if @api_client.config.client_side_validation && cloud_request_id.nil?
        fail ArgumentError, "Missing the required parameter 'cloud_request_id' when calling RealTimeResponse.r_tr_delete_queued_session"
      end
      # resource path
      local_var_path = '/real-time-response/entities/queued-sessions/command/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'session_id'] = session_id
      query_params[:'cloud_request_id'] = cloud_request_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MsaReplyMetaOnly'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_delete_queued_session",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_delete_queued_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a session.
    # @param session_id [String] RTR Session id
    # @param [Hash] opts the optional parameters
    # @return [MsaReplyMetaOnly]
    def r_tr_delete_session(session_id, opts = {})
      data, _status_code, _headers = r_tr_delete_session_with_http_info(session_id, opts)
      data
    end

    # Delete a session.
    # @param session_id [String] RTR Session id
    # @param [Hash] opts the optional parameters
    # @return [Array<(MsaReplyMetaOnly, Integer, Hash)>] MsaReplyMetaOnly data, response status code and response headers
    def r_tr_delete_session_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_delete_session ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling RealTimeResponse.r_tr_delete_session"
      end
      # resource path
      local_var_path = '/real-time-response/entities/sessions/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'session_id'] = session_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MsaReplyMetaOnly'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_delete_session",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_delete_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Execute an active responder command on a single host.
    # @param body [DomainCommandExecuteRequest] Use this endpoint to run these [real time response commands](https://falcon.crowdstrike.com/documentation/page/b8c1738c/real-time-response-and-network-containment#k893b7c0): - &#x60;cat&#x60; - &#x60;cd&#x60; - &#x60;clear&#x60; - &#x60;cp&#x60; - &#x60;encrypt&#x60; - &#x60;env&#x60; - &#x60;eventlog&#x60; - &#x60;filehash&#x60; - &#x60;get&#x60; - &#x60;getsid&#x60; - &#x60;help&#x60; - &#x60;history&#x60; - &#x60;ipconfig&#x60; - &#x60;kill&#x60; - &#x60;ls&#x60; - &#x60;map&#x60; - &#x60;memdump&#x60; - &#x60;mkdir&#x60; - &#x60;mount&#x60; - &#x60;mv&#x60; - &#x60;netstat&#x60; - &#x60;ps&#x60; - &#x60;reg query&#x60; - &#x60;reg set&#x60; - &#x60;reg delete&#x60; - &#x60;reg load&#x60; - &#x60;reg unload&#x60; - &#x60;restart&#x60; - &#x60;rm&#x60; - &#x60;runscript&#x60; - &#x60;shutdown&#x60; - &#x60;unmap&#x60; - &#x60;update history&#x60; - &#x60;update install&#x60; - &#x60;update list&#x60; - &#x60;update query&#x60; - &#x60;xmemdump&#x60; - &#x60;zip&#x60;  Required values.  The rest of the fields are unused. **&#x60;base_command&#x60;** Active-Responder command type we are going to execute, for example: &#x60;get&#x60; or &#x60;cp&#x60;.  Refer to the RTR documentation for the full list of commands. **&#x60;command_string&#x60;** Full command string for the command. For example  &#x60;get some_file.txt&#x60; **&#x60;session_id&#x60;** RTR session ID to run the command on
    # @param [Hash] opts the optional parameters
    # @return [DomainCommandExecuteResponseWrapper]
    def r_tr_execute_active_responder_command(body, opts = {})
      data, _status_code, _headers = r_tr_execute_active_responder_command_with_http_info(body, opts)
      data
    end

    # Execute an active responder command on a single host.
    # @param body [DomainCommandExecuteRequest] Use this endpoint to run these [real time response commands](https://falcon.crowdstrike.com/documentation/page/b8c1738c/real-time-response-and-network-containment#k893b7c0): - &#x60;cat&#x60; - &#x60;cd&#x60; - &#x60;clear&#x60; - &#x60;cp&#x60; - &#x60;encrypt&#x60; - &#x60;env&#x60; - &#x60;eventlog&#x60; - &#x60;filehash&#x60; - &#x60;get&#x60; - &#x60;getsid&#x60; - &#x60;help&#x60; - &#x60;history&#x60; - &#x60;ipconfig&#x60; - &#x60;kill&#x60; - &#x60;ls&#x60; - &#x60;map&#x60; - &#x60;memdump&#x60; - &#x60;mkdir&#x60; - &#x60;mount&#x60; - &#x60;mv&#x60; - &#x60;netstat&#x60; - &#x60;ps&#x60; - &#x60;reg query&#x60; - &#x60;reg set&#x60; - &#x60;reg delete&#x60; - &#x60;reg load&#x60; - &#x60;reg unload&#x60; - &#x60;restart&#x60; - &#x60;rm&#x60; - &#x60;runscript&#x60; - &#x60;shutdown&#x60; - &#x60;unmap&#x60; - &#x60;update history&#x60; - &#x60;update install&#x60; - &#x60;update list&#x60; - &#x60;update query&#x60; - &#x60;xmemdump&#x60; - &#x60;zip&#x60;  Required values.  The rest of the fields are unused. **&#x60;base_command&#x60;** Active-Responder command type we are going to execute, for example: &#x60;get&#x60; or &#x60;cp&#x60;.  Refer to the RTR documentation for the full list of commands. **&#x60;command_string&#x60;** Full command string for the command. For example  &#x60;get some_file.txt&#x60; **&#x60;session_id&#x60;** RTR session ID to run the command on
    # @param [Hash] opts the optional parameters
    # @return [Array<(DomainCommandExecuteResponseWrapper, Integer, Hash)>] DomainCommandExecuteResponseWrapper data, response status code and response headers
    def r_tr_execute_active_responder_command_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_execute_active_responder_command ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling RealTimeResponse.r_tr_execute_active_responder_command"
      end
      # resource path
      local_var_path = '/real-time-response/entities/active-responder-command/v1'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'DomainCommandExecuteResponseWrapper'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_execute_active_responder_command",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_execute_active_responder_command\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Execute a command on a single host.
    # @param body [DomainCommandExecuteRequest] Use this endpoint to run these [real time response commands](https://falcon.crowdstrike.com/documentation/page/b8c1738c/real-time-response-and-network-containment#k893b7c0): - &#x60;cat&#x60; - &#x60;cd&#x60; - &#x60;clear&#x60; - &#x60;env&#x60; - &#x60;eventlog&#x60; - &#x60;filehash&#x60; - &#x60;getsid&#x60; - &#x60;help&#x60; - &#x60;history&#x60; - &#x60;ipconfig&#x60; - &#x60;ls&#x60; - &#x60;mount&#x60; - &#x60;netstat&#x60; - &#x60;ps&#x60; - &#x60;reg query&#x60;  Required values.  The rest of the fields are unused. **&#x60;base_command&#x60;** read-only command type we are going to execute, for example: &#x60;ls&#x60; or &#x60;cd&#x60;.  Refer to the RTR documentation for the full list of commands. **&#x60;command_string&#x60;** Full command string for the command. For example  &#x60;cd C:\\some_directory&#x60; **&#x60;session_id&#x60;** RTR session ID to run the command on
    # @param [Hash] opts the optional parameters
    # @return [DomainCommandExecuteResponseWrapper]
    def r_tr_execute_command(body, opts = {})
      data, _status_code, _headers = r_tr_execute_command_with_http_info(body, opts)
      data
    end

    # Execute a command on a single host.
    # @param body [DomainCommandExecuteRequest] Use this endpoint to run these [real time response commands](https://falcon.crowdstrike.com/documentation/page/b8c1738c/real-time-response-and-network-containment#k893b7c0): - &#x60;cat&#x60; - &#x60;cd&#x60; - &#x60;clear&#x60; - &#x60;env&#x60; - &#x60;eventlog&#x60; - &#x60;filehash&#x60; - &#x60;getsid&#x60; - &#x60;help&#x60; - &#x60;history&#x60; - &#x60;ipconfig&#x60; - &#x60;ls&#x60; - &#x60;mount&#x60; - &#x60;netstat&#x60; - &#x60;ps&#x60; - &#x60;reg query&#x60;  Required values.  The rest of the fields are unused. **&#x60;base_command&#x60;** read-only command type we are going to execute, for example: &#x60;ls&#x60; or &#x60;cd&#x60;.  Refer to the RTR documentation for the full list of commands. **&#x60;command_string&#x60;** Full command string for the command. For example  &#x60;cd C:\\some_directory&#x60; **&#x60;session_id&#x60;** RTR session ID to run the command on
    # @param [Hash] opts the optional parameters
    # @return [Array<(DomainCommandExecuteResponseWrapper, Integer, Hash)>] DomainCommandExecuteResponseWrapper data, response status code and response headers
    def r_tr_execute_command_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_execute_command ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling RealTimeResponse.r_tr_execute_command"
      end
      # resource path
      local_var_path = '/real-time-response/entities/command/v1'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'DomainCommandExecuteResponseWrapper'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_execute_command",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_execute_command\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get RTR extracted file contents for specified session and sha256.
    # @param session_id [String] RTR Session id
    # @param sha256 [String] Extracted SHA256 (e.g. &#39;efa256a96af3b556cd3fc9d8b1cf587d72807d7805ced441e8149fc279db422b&#39;)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :filename Filename to use for the archive name and the file within the archive.
    # @return [File]
    def r_tr_get_extracted_file_contents(session_id, sha256, opts = {})
      data, _status_code, _headers = r_tr_get_extracted_file_contents_with_http_info(session_id, sha256, opts)
      data
    end

    # Get RTR extracted file contents for specified session and sha256.
    # @param session_id [String] RTR Session id
    # @param sha256 [String] Extracted SHA256 (e.g. &#39;efa256a96af3b556cd3fc9d8b1cf587d72807d7805ced441e8149fc279db422b&#39;)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :filename Filename to use for the archive name and the file within the archive.
    # @return [Array<(File, Integer, Hash)>] File data, response status code and response headers
    def r_tr_get_extracted_file_contents_with_http_info(session_id, sha256, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_get_extracted_file_contents ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling RealTimeResponse.r_tr_get_extracted_file_contents"
      end
      # verify the required parameter 'sha256' is set
      if @api_client.config.client_side_validation && sha256.nil?
        fail ArgumentError, "Missing the required parameter 'sha256' when calling RealTimeResponse.r_tr_get_extracted_file_contents"
      end
      # resource path
      local_var_path = '/real-time-response/entities/extracted-file-contents/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'session_id'] = session_id
      query_params[:'sha256'] = sha256
      query_params[:'filename'] = opts[:'filename'] if !opts[:'filename'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/x-7z-compressed', 'application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'File'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_get_extracted_file_contents",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_get_extracted_file_contents\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Initialize a new session with the RTR cloud.
    # @param body [DomainInitRequest] **&#x60;device_id&#x60;** The host agent ID to initialize the RTR session on.  RTR will retrieve an existing session for the calling user on this host **&#x60;queue_offline&#x60;** If we should queue this session if the host is offline.  Any commands run against an offline-queued session will be queued up and executed when the host comes online.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @return [DomainInitResponseWrapper]
    def r_tr_init_session(body, opts = {})
      data, _status_code, _headers = r_tr_init_session_with_http_info(body, opts)
      data
    end

    # Initialize a new session with the RTR cloud.
    # @param body [DomainInitRequest] **&#x60;device_id&#x60;** The host agent ID to initialize the RTR session on.  RTR will retrieve an existing session for the calling user on this host **&#x60;queue_offline&#x60;** If we should queue this session if the host is offline.  Any commands run against an offline-queued session will be queued up and executed when the host comes online.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :timeout Timeout for how long to wait for the request in seconds, default timeout is 30 seconds. Maximum is 5 minutes. (default to 30)
    # @option opts [String] :timeout_duration Timeout duration for how long to wait for the request in duration syntax. Example, &#x60;10s&#x60;. Valid units: &#x60;ns, us, ms, s, m, h&#x60;. Maximum is 5 minutes. (default to '30s')
    # @return [Array<(DomainInitResponseWrapper, Integer, Hash)>] DomainInitResponseWrapper data, response status code and response headers
    def r_tr_init_session_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_init_session ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling RealTimeResponse.r_tr_init_session"
      end
      # resource path
      local_var_path = '/real-time-response/entities/sessions/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'timeout'] = opts[:'timeout'] if !opts[:'timeout'].nil?
      query_params[:'timeout_duration'] = opts[:'timeout_duration'] if !opts[:'timeout_duration'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'DomainInitResponseWrapper'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_init_session",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_init_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of session_ids.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :offset Starting index of overall result set from which to return ids.
    # @option opts [Integer] :limit Number of ids to return.
    # @option opts [String] :sort Sort by spec. Ex: &#39;date_created|asc&#39;.
    # @option opts [String] :filter Optional filter criteria in the form of an FQL query. For more information about FQL queries, see our [FQL documentation in Falcon](https://falcon.crowdstrike.com/support/documentation/45/falcon-query-language-feature-guide).user_id can accept a special value @me which will restrict results to records with current users ID.
    # @return [DomainListSessionsResponseMsa]
    def r_tr_list_all_sessions(opts = {})
      data, _status_code, _headers = r_tr_list_all_sessions_with_http_info(opts)
      data
    end

    # Get a list of session_ids.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :offset Starting index of overall result set from which to return ids.
    # @option opts [Integer] :limit Number of ids to return.
    # @option opts [String] :sort Sort by spec. Ex: &#39;date_created|asc&#39;.
    # @option opts [String] :filter Optional filter criteria in the form of an FQL query. For more information about FQL queries, see our [FQL documentation in Falcon](https://falcon.crowdstrike.com/support/documentation/45/falcon-query-language-feature-guide).user_id can accept a special value @me which will restrict results to records with current users ID.
    # @return [Array<(DomainListSessionsResponseMsa, Integer, Hash)>] DomainListSessionsResponseMsa data, response status code and response headers
    def r_tr_list_all_sessions_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_list_all_sessions ...'
      end
      # resource path
      local_var_path = '/real-time-response/queries/sessions/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'filter'] = opts[:'filter'] if !opts[:'filter'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DomainListSessionsResponseMsa'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_list_all_sessions",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_list_all_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of files for the specified RTR session.
    # @param session_id [String] RTR Session id
    # @param [Hash] opts the optional parameters
    # @return [DomainListFilesResponseWrapper]
    def r_tr_list_files(session_id, opts = {})
      data, _status_code, _headers = r_tr_list_files_with_http_info(session_id, opts)
      data
    end

    # Get a list of files for the specified RTR session.
    # @param session_id [String] RTR Session id
    # @param [Hash] opts the optional parameters
    # @return [Array<(DomainListFilesResponseWrapper, Integer, Hash)>] DomainListFilesResponseWrapper data, response status code and response headers
    def r_tr_list_files_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_list_files ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling RealTimeResponse.r_tr_list_files"
      end
      # resource path
      local_var_path = '/real-time-response/entities/file/v1'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'session_id'] = session_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DomainListFilesResponseWrapper'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_list_files",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_list_files\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of files for the specified RTR session.
    # @param session_id [String] RTR Session id
    # @param [Hash] opts the optional parameters
    # @return [DomainListFilesV2ResponseWrapper]
    def r_tr_list_files_v2(session_id, opts = {})
      data, _status_code, _headers = r_tr_list_files_v2_with_http_info(session_id, opts)
      data
    end

    # Get a list of files for the specified RTR session.
    # @param session_id [String] RTR Session id
    # @param [Hash] opts the optional parameters
    # @return [Array<(DomainListFilesV2ResponseWrapper, Integer, Hash)>] DomainListFilesV2ResponseWrapper data, response status code and response headers
    def r_tr_list_files_v2_with_http_info(session_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_list_files_v2 ...'
      end
      # verify the required parameter 'session_id' is set
      if @api_client.config.client_side_validation && session_id.nil?
        fail ArgumentError, "Missing the required parameter 'session_id' when calling RealTimeResponse.r_tr_list_files_v2"
      end
      # resource path
      local_var_path = '/real-time-response/entities/file/v2'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'session_id'] = session_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DomainListFilesV2ResponseWrapper'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_list_files_v2",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_list_files_v2\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get queued session metadata by session ID.
    # @param body [MsaIdsRequest] **&#x60;ids&#x60;** List of RTR sessions to retrieve.  RTR will only return the sessions that were created by the calling user
    # @param [Hash] opts the optional parameters
    # @return [DomainQueuedSessionResponseWrapper]
    def r_tr_list_queued_sessions(body, opts = {})
      data, _status_code, _headers = r_tr_list_queued_sessions_with_http_info(body, opts)
      data
    end

    # Get queued session metadata by session ID.
    # @param body [MsaIdsRequest] **&#x60;ids&#x60;** List of RTR sessions to retrieve.  RTR will only return the sessions that were created by the calling user
    # @param [Hash] opts the optional parameters
    # @return [Array<(DomainQueuedSessionResponseWrapper, Integer, Hash)>] DomainQueuedSessionResponseWrapper data, response status code and response headers
    def r_tr_list_queued_sessions_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_list_queued_sessions ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling RealTimeResponse.r_tr_list_queued_sessions"
      end
      # resource path
      local_var_path = '/real-time-response/entities/queued-sessions/GET/v1'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'DomainQueuedSessionResponseWrapper'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_list_queued_sessions",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_list_queued_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get session metadata by session id.
    # @param body [MsaIdsRequest] **&#x60;ids&#x60;** List of RTR sessions to retrieve.  RTR will only return the sessions that were created by the calling user
    # @param [Hash] opts the optional parameters
    # @return [DomainSessionResponseWrapper]
    def r_tr_list_sessions(body, opts = {})
      data, _status_code, _headers = r_tr_list_sessions_with_http_info(body, opts)
      data
    end

    # Get session metadata by session id.
    # @param body [MsaIdsRequest] **&#x60;ids&#x60;** List of RTR sessions to retrieve.  RTR will only return the sessions that were created by the calling user
    # @param [Hash] opts the optional parameters
    # @return [Array<(DomainSessionResponseWrapper, Integer, Hash)>] DomainSessionResponseWrapper data, response status code and response headers
    def r_tr_list_sessions_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_list_sessions ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling RealTimeResponse.r_tr_list_sessions"
      end
      # resource path
      local_var_path = '/real-time-response/entities/sessions/GET/v1'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'DomainSessionResponseWrapper'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_list_sessions",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_list_sessions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Refresh a session timeout on a single host.
    # @param body [DomainInitRequest] **&#x60;device_id&#x60;** The host agent ID to refresh the RTR session on.  RTR will retrieve an existing session for the calling user on this host
    # @param [Hash] opts the optional parameters
    # @return [DomainInitResponseWrapper]
    def r_tr_pulse_session(body, opts = {})
      data, _status_code, _headers = r_tr_pulse_session_with_http_info(body, opts)
      data
    end

    # Refresh a session timeout on a single host.
    # @param body [DomainInitRequest] **&#x60;device_id&#x60;** The host agent ID to refresh the RTR session on.  RTR will retrieve an existing session for the calling user on this host
    # @param [Hash] opts the optional parameters
    # @return [Array<(DomainInitResponseWrapper, Integer, Hash)>] DomainInitResponseWrapper data, response status code and response headers
    def r_tr_pulse_session_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: RealTimeResponse.r_tr_pulse_session ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling RealTimeResponse.r_tr_pulse_session"
      end
      # resource path
      local_var_path = '/real-time-response/entities/refresh-session/v1'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
        header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'DomainInitResponseWrapper'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['oauth2']

      new_options = opts.merge(
        :operation => :"RealTimeResponse.r_tr_pulse_session",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: RealTimeResponse#r_tr_pulse_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
