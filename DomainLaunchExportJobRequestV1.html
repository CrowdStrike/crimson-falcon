<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falcon::DomainLaunchExportJobRequestV1

## Properties

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **entity** | **String** | The entity type. This can be one of: [&#x60;notification-exposed-data-record&#x60;, &#x60;historical-search-exposed-data-record&#x60;, &#x60;bulk-historical-search-exposed-data-record&#x60;] |  |
| **export_type** | **String** | The file type of the export. This can be one of: [&#x60;json&#x60;, &#x60;csv&#x60;] |  |
| **filter** | **String** | FQL query to filter entities by. Possible filter properties depend on the entity type. |  |
| **human_readable** | **Boolean** | If set to true (default), the field names in the exported file will resemble the table header in the UI (e.g. {{TITLE}}quot;Hash type{{TITLE}}quot;), otherwise the API level field names will be used (e.g. {{TITLE}}quot;hash_type{{TITLE}}quot;) |  |
| **sort** | **String** | Possible order by fields: created_timestamp, last_updated_timestamp. Ex: &#39;last_updated_timestamp|desc&#39; | [optional] |

## Example

```ruby
require 'crimson-falcon'

instance = Falcon::DomainLaunchExportJobRequestV1.new(
  entity: null,
  export_type: null,
  filter: null,
  human_readable: null,
  sort: null
)
``` - Crimson Falcon Documentation</title>
    <style>
        :root {
            --crwd-red: #EC0000;
            --crwd-dark-red: #B52026;
            --crwd-black: #000000;
            --crwd-gray: #666666;
            --crwd-light-gray: #f8f9fa;
            --crwd-border: #e1e4e8;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Red Hat Display", "Segoe UI", Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: var(--crwd-black);
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
        }

        .header {
            border-bottom: 3px solid var(--crwd-red);
            margin-bottom: 30px;
            padding-bottom: 20px;
        }

        .breadcrumb {
            font-size: 14px;
            margin-bottom: 20px;
            color: var(--crwd-gray);
        }

        .breadcrumb a {
            color: var(--crwd-red);
            text-decoration: none;
        }

        .breadcrumb a:hover {
            color: var(--crwd-dark-red);
            text-decoration: underline;
        }

        h1 {
            color: var(--crwd-red);
            font-size: 2.5em;
            margin: 0 0 10px 0;
            font-weight: 600;
        }

        h2 {
            color: var(--crwd-dark-red);
            font-size: 1.8em;
            margin: 30px 0 15px 0;
            font-weight: 600;
            border-bottom: 2px solid var(--crwd-light-gray);
            padding-bottom: 8px;
        }

        h3 {
            color: var(--crwd-black);
            font-size: 1.4em;
            margin: 25px 0 12px 0;
            font-weight: 600;
        }

        h4, h5, h6 {
            color: var(--crwd-black);
            font-weight: 600;
            margin: 20px 0 10px 0;
        }

        a {
            color: var(--crwd-red);
            text-decoration: none;
        }

        a:hover {
            color: var(--crwd-dark-red);
            text-decoration: underline;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            background-color: #ffffff;
            border: 1px solid var(--crwd-border);
        }

        th {
            background-color: var(--crwd-red);
            color: white;
            font-weight: 600;
            padding: 12px;
            text-align: left;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid var(--crwd-border);
        }

        tr:nth-child(even) {
            background-color: var(--crwd-light-gray);
        }

        tr:hover {
            background-color: #e8f4f8;
        }

        pre {
            background-color: #f6f8fA;
            border: 1px solid var(--crwd-border);
            border-left: 4px solid var(--crwd-red);
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 20px 0;
        }

        code {
            background-color: var(--crwd-light-gray);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        blockquote {
            border-left: 4px solid var(--crwd-red);
            margin: 20px 0;
            padding: 10px 20px;
            background-color: var(--crwd-light-gray);
            font-style: italic;
        }

        .back-link {
            margin: 40px 0 20px 0;
            padding: 20px 0;
            border-top: 1px solid var(--crwd-border);
            text-align: center;
        }

        .back-link a {
            display: inline-block;
            background-color: var(--crwd-red);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            text-decoration: none;
            font-weight: 600;
            transition: background-color 0.3s ease;
        }

        .back-link a:hover {
            background-color: var(--crwd-dark-red);
        }

        /* Syntax highlighting for Ruby code */
        .highlight .k { color: #d73a49; font-weight: bold; } /* Keywords */
        .highlight .s { color: #032f62; } /* Strings */
        .highlight .c { color: #6a737d; font-style: italic; } /* Comments */
        .highlight .n { color: #24292e; } /* Names */
        .highlight .o { color: #d73a49; } /* Operators */
        .highlight .p { color: #24292e; } /* Punctuation */
        .highlight .nb { color: #005cc5; } /* Built-ins */
        .highlight .nf { color: #6f42c1; } /* Functions */

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }

            h1 {
                font-size: 2em;
            }

            h2 {
                font-size: 1.5em;
            }

            table {
                font-size: 14px;
            }

            pre {
                padding: 12px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <nav class="breadcrumb">
            üè† <a href="../index.html">Documentation</a> > DomainLaunchExportJobRequestV1
        </nav>
        <h1>Falcon::DomainLaunchExportJobRequestV1

## Properties

| Name | Type | Description | Notes |
| ---- | ---- | ----------- | ----- |
| **entity** | **String** | The entity type. This can be one of: [&#x60;notification-exposed-data-record&#x60;, &#x60;historical-search-exposed-data-record&#x60;, &#x60;bulk-historical-search-exposed-data-record&#x60;] |  |
| **export_type** | **String** | The file type of the export. This can be one of: [&#x60;json&#x60;, &#x60;csv&#x60;] |  |
| **filter** | **String** | FQL query to filter entities by. Possible filter properties depend on the entity type. |  |
| **human_readable** | **Boolean** | If set to true (default), the field names in the exported file will resemble the table header in the UI (e.g. {{PAGE_TITLE}}quot;Hash type{{PAGE_TITLE}}quot;), otherwise the API level field names will be used (e.g. {{PAGE_TITLE}}quot;hash_type{{PAGE_TITLE}}quot;) |  |
| **sort** | **String** | Possible order by fields: created_timestamp, last_updated_timestamp. Ex: &#39;last_updated_timestamp|desc&#39; | [optional] |

## Example

```ruby
require 'crimson-falcon'

instance = Falcon::DomainLaunchExportJobRequestV1.new(
  entity: null,
  export_type: null,
  filter: null,
  human_readable: null,
  sort: null
)
```</h1>
    </div>

    <main>
        <h1 id="falcondomainlaunchexportjobrequestv1">Falcon::DomainLaunchExportJobRequestV1</h1>

<h2 id="properties">Properties</h2>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Notes</th>
      <th>¬†</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>entity</strong></td>
      <td><strong>String</strong></td>
      <td>The entity type. This can be one of: [`notification-exposed-data-record`, `historical-search-exposed-data-record`, `bulk-historical-search-exposed-data-record`]</td>
      <td>¬†</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td><strong>export_type</strong></td>
      <td><strong>String</strong></td>
      <td>The file type of the export. This can be one of: [`json`, `csv`]</td>
      <td>¬†</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td><strong>filter</strong></td>
      <td><strong>String</strong></td>
      <td>FQL query to filter entities by. Possible filter properties depend on the entity type.</td>
      <td>¬†</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td><strong>human_readable</strong></td>
      <td><strong>Boolean</strong></td>
      <td>If set to true (default), the field names in the exported file will resemble the table header in the UI (e.g. \"Hash type\"), otherwise the API level field names will be used (e.g. \"hash_type\")</td>
      <td>¬†</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td><strong>sort</strong></td>
      <td><strong>String</strong></td>
      <td>Possible order by fields: created_timestamp, last_updated_timestamp. Ex: 'last_updated_timestamp</td>
      <td>desc'</td>
      <td>[optional]</td>
    </tr>
  </tbody>
</table>

<h2 id="example">Example</h2>

<p>```ruby
require ‚Äòcrimson-falcon‚Äô</p>

<p>instance = Falcon::DomainLaunchExportJobRequestV1.new(
  entity: null,
  export_type: null,
  filter: null,
  human_readable: null,
  sort: null
)
```</p>


    </main>

    <div class="back-link">
        <a href="../index.html">‚Üê Back to Documentation Index</a>
    </div>
</body>
</html>
